% ------------------------------------------------------------------------
% ReadOutput_Picoharp reads and parses a PTU file generated by Picoharp TCSPC 
% device (PicoQuant) and converts into a matlab structure called output. 
% Input: PTU file (.out extension)
% Output: Matlab structure called output that contains photon records and
% special events (markers)

% ReadOutput_Picoharp is based on similar functions that parses files generated
% by Hydraharp TCSPC device by PicoQuant:
%  1) Read_PTU.m written by PicoQuant (https://github.com/PicoQuant)
%  2) Read_PTU_V1.m written by Omri Bar-Elli and Ron Tenne
%     (https://www.mathworks.com/matlabcentral/fileexchange/61789-read_ptu_v1-filepath)
%     Read_PTU_V1.m parses bin files generated by Hydraharp
% The second function is ~100x faster than the first. I added a new
% feature, see parseOutData(output), which parses the data in a readable
% way and also performs some sanity checks along the way.
% 3) ReadOutput_Hydraharp.m that is a sim written for Hydraharp devices 
%    written by my colleague, Ji Hyun Nam
%
%   TO DO: Remove "Progress" as an input. The number of events shown at the
%          end of the acquisition script doesn't necessarily correspond to
%          the number of parsed events. Talked to PicoQuant about this and
%          it's fine: "Progress" is just an approximate value.
% ------------------------------------------------------------------------
function output = ReadOutput_Picoharp_3(filepath) %, Resolution, SyncRate, Tacq, Tgalvo, Progress)
fprintf('\n*** Parsing %s ***', filepath)

% Open file
fprintf('\nOpening events file...')
fid = fopen(filepath);
fprintf('done!\n')

% Decode function
fprintf('Reading Picoharp T3 data (may take a while)...')


[output, cnt_ph, cnt_ov, cnt_ma] = ReadPT3(fid);


fclose(fid);
fprintf(1,'Ready!  \n\n');
fprintf(1,'\nStatistics obtained from the data:\n');
fprintf(1,'\n%i photons, %i overflows, %i markers.',cnt_ph, cnt_ov, cnt_ma);
fprintf(1,'\n');



fprintf('done!')
fprintf('\nStatistics obtained from the data: ');
fprintf('%i photons, %i overflows, %i markers.', cnt_ph, cnt_ov, cnt_ma);
if cnt_ma ==0
    warning('Marker(s) were not detected!')
end
% Perform a sanity check: the total number of events (Progress) should be
% equal to the some of the counts (parsed events)
% sumCounts = cnt_ph+cnt_ov+cnt_ma;
% fprintf('\n3b) Sanity check...TCSPC collected %i events, this function parsed %i events (%i difference)', Progress, sumCounts, Progress-sumCounts)

% Parse events
%fprintf('\nCreating a MATLAB structure (may take a while)...')
output = parseOutData(output);
%fprintf('done!\n')
end

function [output, cnt_ph, cnt_ov, cnt_ma] = ReadPT3(fid)

% ofltime = 0;
WRAPAROUND=65536;

T3Record = fread(fid, inf, 'uint32=>uint32', 'ieee-le'); % all 32 bits:
    % T3Record = int2bit(T3Record,32)
    %   +-------------------------------+  +-------------------------------+
    %   |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|  |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
    %   +-------------------------------+  +-------------------------------+


    nsync = bitand(T3Record,65535);       % the lowest 16 bits:
    %   +-------------------------------+  +-------------------------------+
    %   | | | | | | | | | | | | | | | | |  |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
    %   +-------------------------------+  +-------------------------------+

    nsync2=nsync; % make a copy since we need the original nsync later.

    dtime=mod(idivide(T3Record,2^10),2^15); % next 15 bits
%   the dtime unit depends on "Resolution" that can be obtained from header
%   DTime: Arrival time (units) of Photon after last Sync event
%   DTime * Resolution = Real time arrival of Photon after last Sync event


    chan = bitand(bitshift(T3Record,-28),15);   % the upper 4 bits:
    %   +-------------------------------+  +-------------------------------+
    %   |x|x|x|x| | | | | | | | | | | | |  | | | | | | | | | | | | | | | | |
    %   +-------------------------------+  +-------------------------------+
    % truensync = ofltime + nsync;


    % Detect whenever you have an overflow 
        % Everytime an overflow occurs, the timing shifts for all photon
        % events
    
    overflow_2 = (chan == 15) & (bitand(bitshift(T3Record,-16),15) == 0);

    % Add WrapAround
    overflow_3 = cumsum(overflow_2).*WRAPAROUND;
    OverflowCorrection = overflow_3;
    
    % % how many overflows in the file:
    cnt_ov = max(OverflowCorrection)/WRAPAROUND;
    
    % Find Special Records
    %   1. Either it is a marker
    %   2. Or an Overflow Event
    special = chan == 15;

    % Get Special Records
    T3Record_Sp = T3Record(special);

    % Get Photon Records
    % Photon Channel -- All non-special records
    %       1. This will only work for 1 channel - will have to rewrite for
    %           additional channels
    output.ph_channel = chan(special==0);
    output.ph_dtime = bitand(bitshift(T3Record(special==0),-16),4095);
    output.ph_sync = OverflowCorrection(special==0) + double( nsync(special==0));
    cnt_ph = length(output.ph_dtime);

    % Get Markers 
    % Marker Records
    markers_rec = (chan == 15) & (bitand(bitshift(T3Record,-16),15) > 0);
    output.mark_sync = OverflowCorrection(markers_rec) + double( nsync(markers_rec));
    output.mark_chan = double(chan(markers_rec));
    output.mark_dtime = dtime(markers_rec);
    cnt_ma = length(output.mark_chan);

end


%% CRETE A READABLE STRUCTURE
function output = parseOutData(output)
% Convert uint32 to double
output.ph_sync = double(output.ph_sync);
output.ph_dtime = double(output.ph_dtime);
output.ph_channel = double(output.ph_channel);
output.mark_dtime = double(output.mark_dtime);
output.mark_sync = double(output.mark_sync);
output.mark_chan = double(output.mark_chan);

% EVENTS

% *** PHOTONS *** %
% Channel 1 (HH/PH)
pho = find(output.ph_channel == 1);
output.ch1 = [output.ph_sync(pho) output.ph_dtime(pho)];
clear pho


% *** MARKERS *** %
% Marker l (HH)
output.mar1 = output.mark_sync((output.mark_chan == 15));


% Removing unncessary fields
output = rmfield(output, 'ph_sync');
output = rmfield(output, 'ph_dtime');
output = rmfield(output, 'ph_channel');
output = rmfield(output, 'mark_dtime');
output = rmfield(output, 'mark_sync');
output = rmfield(output, 'mark_chan');
end
